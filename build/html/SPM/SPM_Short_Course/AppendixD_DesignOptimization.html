<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Appendix D: DesignOptimization &mdash; Andy&#39;s Brain Book 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Functional Connectivity and the CONN Toolbox" href="../../FunctionalConnectivity/CONN_Overview.html" />
    <link rel="prev" title="Appendix C: Parametric Modulation" href="AppendixC_ParametricModulation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Andy's Brain Book
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Install</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation/fsl_mac_install.html">Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Unix for Neuroimagers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_Intro.html">What is Unix?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_01_Navigation.html">Unix Tutorial #1: 目录操作 (Directories and Navigation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_02_CopyRemove.html">Unix Tutorial #2: Copying and Removing Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_03_ReadingTextFiles.html">Unix Tutorial #3: Reading Text Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_04_ShellsVariables.html">Unix Tutorial #4: Shells and Path Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_05_ForLoops.html">Unix Tutorial #5: For-Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_06_IfElse.html">Unix Tutorial #6: Conditional Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_07_Scripting.html">Unix Tutorial #7: Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_08_Sed.html">Unix Tutorial #8: The Sed Command</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../unix/Unix_09_AutomatingTheAnalysis.html">Unix Tutorial #9: Automating The Analysis</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">fMRI Short Course with FSL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_Intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_01_DataDownload.html">fMRI Tutorial #1: Downloading the Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_02_ExperimentalDesign.html">fMRI Tutorial #2: Overview of The Flanker Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_03_LookingAtTheData.html">fMRI Tutorial #3: Looking at the Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_04_Preprocessing.html">fMRI Tutorial #4: Preprocessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_05_1stLevelAnalysis.html">fMRI Tutorial #5: Statistics and Modeling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_06_Scripting.html">fMRI Tutorial #6: Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_07_2ndLevelAnalysis.html">fMRI Tutorial #7: 2nd-Level Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_08_3rdLevelAnalysis.html">fMRI Tutorial #8: 3rd-Level Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_09_ROIAnalysis.html">fMRI Tutorial #9: ROI Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_10_Summary.html">fMRI Tutorial #10: Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fMRI_Short_Course/fMRI_Appendices.html">fMRI Short Course: Appendices</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FreeSurfer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../FreeSurfer/FreeSurfer_Introduction.html">FreeSurfer Short Course</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">E-Prime</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../E-Prime/E-Prime_Overview.html">Overview of E-Prime</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">AFNI</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../AFNI/AFNI_Overview.html">AFNI Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">SPM</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../SPM_Overview.html">SPM Overview</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../SPM_Overview.html#what-is-spm">What is SPM?</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="SPM_fMRI_Intro.html">Introduction to SPM</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_01_DataDownload.html">SPM Tutorial #1: Downloading the Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_02_Flanker.html">SPM Tutorial #2: The Flanker Task</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_03_LookingAtData.html">SPM Tutorial #3: Looking at the Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_04_Preprocessing.html">SPM Tutorial #4: Preprocessing</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_05_1stLevelAnalysis.html">SPM Tutorial #5: Statistics and Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_06_Scripting.html">SPM Tutorial #6: Scripting</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_07_SettingTheOrigin.html">SPM Tutorial #7: Setting the Origin</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_08_GroupAnalysis.html">SPM Tutorial #8: Group Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_Intermezzo_Toolboxes.html">SPM Intermezzo: Toolboxes</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_09_ROIAnalysis.html">SPM Tutorial #9: ROI Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="SummaryStatistics.html">Appendix A: Summary Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="SPM_PPI.html">Appendix B: Psychophysiological Interactions (PPI) in SPM</a></li>
<li class="toctree-l3"><a class="reference internal" href="AppendixC_ParametricModulation.html">Appendix C: Parametric Modulation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Appendix D: DesignOptimization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview-different-types-of-designs">Overview: Different Types of Designs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-optimization-with-optseq2">Design Optimization with optseq2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#design-optimization-with-optimizex">Design Optimization with OptimizeX</a></li>
<li class="toctree-l4"><a class="reference internal" href="#evaluating-design-efficiency">Evaluating Design Efficiency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#video">Video</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Functional Connectivity with the CONN Toolbox</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../FunctionalConnectivity/CONN_Overview.html">Functional Connectivity and the CONN Toolbox</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parametric Modulation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../PM/PM_Overview.html">Parametric Modulation in SPM, FSL, and AFNI</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Image Visualization with MRIcroGL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../MRIcroGL/MRIcroGL_Overview.html">Image Visualization with MRIcroGL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction to the Human Connectome Project (HCP)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../HCP/HCP_Overview.html">Introduction to the Human Connectome Project</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Finite Impulse Response (FIR) Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../FIR/FIR_Overview.html">Finite Impulse Response (FIR)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">fMRI Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Practicals/DesignOptimization.html">Design Optimization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Diffusion Analysis with MRtrix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../MRtrix/MRtrix_Introduction.html">Introduction to MRtrix</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ASL Analysis</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ASL/ASL_Techniques.html">fASL Tutorial #1: Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ASL/fASL_02_Download.html">fASL Tutorial #2: Downloading and Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ASL/fASL_03_Task.html">fASL Tutorial #3: The N-Back Task</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ASL/04_fASL_GUI.html">fASL Tutorial #4: The GUI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ASL/05_fASL_Results.html">fASL Tutorial #5: Examining the Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ASL/06_fASL_Quantification.html">fASL Tutorial #6: Quantification</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Frequently Asked Questions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../FrequentlyAskedQuestions/FrequentlyAskedQuestions.html">Frequently Asked Questions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Statistics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Statistics/GIMME.html">GIMME (Group Iterative Multiple Model Estimation)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Open Science</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../OpenScience/OS_Overview.html">Open Science</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Normalization Tools (ANTs)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ANTs/ANTs_Overview.html">Advanced Normalization Tools (ANTs)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tract-Based Spatial Statistics (TBSS)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../TBSS/TBSS_Overview.html">Introduction to Tract-Based Spatial Statistics (TBSS)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Statistics for Neuroimagers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Stats/Stats_Overview.html">Statistics for Neuroimagers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Machine Learning for Neuroimagers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ML/ML_Overview.html">Machine Learning for Neuroimagers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Slicer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Slicer/Slicer_Overview.html">Slicer Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">CAT12</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../CAT12/CAT12_Overview.html">Voxel-Based Morphometry with CAT12</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Using the Supercomputer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Supercomputer/Supercomputer_Overview.html">Introduction to Supercomputing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Matlab for Neuroimagers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Matlab/Matlab_Overview.html">Matlab for Neuroimagers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ITK-Snap</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ITK-Snap/ITK-Snap_Overview.html">ITK-Snap_Overview</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python for Neuroimagers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../PythonForNeuroimagers/PythonForNeuroimagers_Overview.html">Python for Neuroimagers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Meta-Analysis for fMRI</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../MetaAnalysis/MetaAnalysis_Overview.html">Meta-Analysis for Neuroimagers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Andy's Brain Book</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../SPM_Overview.html">SPM Overview</a></li>
      <li class="breadcrumb-item active">Appendix D: DesignOptimization</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/SPM/SPM_Short_Course/AppendixD_DesignOptimization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="appendix-d-designoptimization">
<span id="appendixd-designoptimization"></span><h1>Appendix D: DesignOptimization<a class="headerlink" href="#appendix-d-designoptimization" title="Link to this heading"></a></h1>
<section id="overview-different-types-of-designs">
<h2>Overview: Different Types of Designs<a class="headerlink" href="#overview-different-types-of-designs" title="Link to this heading"></a></h2>
<p>If you are thinking about creating your own experiment, you have three main types of task-based designs to choose from: block designs, event-related designs, or a mixture of both block and event-related designs, often referred to as mixed designs. Event-related designs can be further subdivided into either rapid or slow event-related designs, depending on the amount of jitter in the experiment, or how much time there is between consecutive trials. These three designs have been the main ones used by researchers since the beginning of task-based fMRI, and although there are exceptions for certain experiments - for example, using a sparse design to briefly stop scanning while the subject listens to an auditory stimulus, before the scanner begins to measure the BOLD signal again - these too can be seen as variants of the three designs, as you will see.</p>
<p>The earliest task-based experiment was a block design used in the Kwong et al. 1992 paper: The participant in the scanner looked at a flashing checkerboard pattern for thirty seconds, followed by thirty seconds of no checkerboard, and this on/off pattern repeated for the duration of the experiment. This design, in other words, had two conditions: Checkerboard and No Checkerboard, each one lasting for a relatively long time. We call it a block design because many instances of the same condition occur in a given chunk of time, usually lasting at least a dozen seconds, and this period of time, when shown on a line depicting the time-course of the experiment, tends to look like a block, also called a boxcar. The period of time between blocks is also usually long enough to allow the BOLD signal to resolve back to baseline, which can take around 12-20 seconds. Furthermore, we model the entire block as a single instance of that condition, instead of modeling all of the trials within that block individually. The idea is that all of the trials should elicit the same basic pattern of BOLD activity, and that by clustering them together, the signal will be enhanced, and the noise will tend to cancel itself out.</p>
<figure class="align-default" id="id3">
<img alt="../../_images/AppendixD_Kwong_BlockDesign.png" src="../../_images/AppendixD_Kwong_BlockDesign.png" />
<figcaption>
<p><span class="caption-text">Figure from Kwong et al., 1992. Each <code class="docutils literal notranslate"><span class="pre">off</span></code> and <code class="docutils literal notranslate"><span class="pre">on</span></code> rectangle encompasses sixty seconds of that condition, in which the participant either saw a blank screen or a flashing checkerboard. During the <code class="docutils literal notranslate"><span class="pre">on</span></code> block, notice how the BOLD Signal Intensity tends to increase and then plateau after about a dozen seconds.</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>If the condition we are modeling is straightforward for the participant to understand and if the condition elicits a robust BOLD signal, then a block design can generate the most statistical power, as it has the highest signal-to-noise ratio of all possible designs. However, as a researcher you need to consider the psychological effects as well. Although on paper block designs should yield the greatest statistical power, they can also become boring for the participant, due to the repetitive, predictable nature of identical or similar trials happening for long periods of time. This can lead to confounds such as habituation or prediction effects, and the participant’s behavioral responses may also become uniform, which you may not want.</p>
<p>In contrast, event-related designs place individual trials from different conditions next to each other with a smaller interval of time between them. The order can be determined ahead of time as part of the experimental setup, or it can be randomized. Slow event-related designs typically have at least 12-15 seconds between consecutive trials - enough time for the BOLD response to go back to baseline before the next stimulus elicits another BOLD signal. Rapid event-related designs, on the other hand, have less time between consecutive trials, and therefore there is overlap in the BOLD responses. Both types of designs are shown below, which are taken from the AFNI website:</p>
<figure class="align-default" id="id4">
<img alt="../../_images/AppendixD_SlowEventRelatedDesign.jpg" src="../../_images/AppendixD_SlowEventRelatedDesign.jpg" />
<figcaption>
<p><span class="caption-text">An example timing schedule for a slow event-related design. The top row depicts the individual presentation of each trial (each one color-coded to represent a different condition), while the middle row shows the corresponding hemodynamic response for each stimulus type. The bottom row illustrates the sum of the HRFs from the middle row. Note that there is enough time between trials to allow the BOLD response to go back to its baseline before the stimulus was presented; therefore, the shape of the individual and summed BOLD responses look identical.</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="id5">
<img alt="../../_images/AppendixD_RapidEventRelatedDesign.jpg" src="../../_images/AppendixD_RapidEventRelatedDesign.jpg" />
<figcaption>
<p><span class="caption-text">An example timing schedule for a rapid event-related design; the meaning of each row is the same as in the figure immediately above. Note that in this case there is less time between consecutive trials, and there is considerable overlap between their BOLD responses. Consequently, the sum of their BOLD responses (depicted in the bottom row) is a convolution, or moving average, of the individual responses.</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Regardless of whether you use slow or rapid event-related designs, the idea behind both of them is to make the experiment more engaging for the participant, while maximizing the amount of individual trials that are presented and maximizing the discriminability between conditions. Increasing the number of trials is straightforward enough, but what does it mean to maximize the discriminability between conditions? Remember that the typical BOLD response takes time to unfold, and generally looks like a gamma distribution - that is, a bell-shaped curve with a long tail skewed to the right. If many BOLD responses occur close enough in time so that one response begins before the previous response has resolved, the two are averaged together over time. This phenomenon, known as <strong>convolution</strong>, is part of the reason that the observed BOLD signal usually looks noisy, jagged, and random. There are other factors contributing to the overall messiness of the signal, but even when these other sources of noise are removed from the data, we are left with a convolved signal that obscures the amplitude of each individual condition. In order to accurately calculate the amplitude for each condition, we therefore need to deconvolve the signal; in other words, we need to disentangle the knot of BOLD responses that overlap with each other.</p>
<p>In principle, deconvolution is easy to understand, and all fMRI analysis packages contain algorithms to do it for you. The catch is that the overlap should not be too regular - that is, the interval between one stimulus and the next cannot be the same, or close to the same, every time. Such regularity leads to collinearity, which means that two regressors are highly correlated. The term collinearity is used in statistics to describe one regressor being predicted by a linear combination of other regressors; if this happens, the possible number of solutions can become close to infinite, making it impossible to estimate the beta weights for individual regressors. This is illustrated in the following figure, also taken from the AFNI website:</p>
<figure class="align-default" id="id6">
<img alt="../../_images/AppendixD_Collinearity.png" src="../../_images/AppendixD_Collinearity.png" />
<figcaption>
<p><span class="caption-text">Example of collinearity. If these three conditions (highlighted in green, red, and blue) always occur at the same time relative to each other, then it becomes impossible to determine how much each condition contributed to the overall convoluted signal, depicted here in magenta and pinned to a single value. Randomized intertrial intervals, or jitter, is needed to accurately disentangle the convoluted signal into its constituent parts.</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To understand this more intuitively, imagine that you are at a noisy party in which you are talking with two people. If one person talks, and then pauses, and then the other person talks, you will probably be able to understand each of them, the background noise notwithstanding. If they both talk at the same time, on the other hand, it will be difficult to understand what each of them are saying; and if they repeat what they just said with one person beginning to talk a few seconds after the other person began to talk, you would probably understand the part of each person’s conversation that didn’t overlap with the other’s. If they keep repeating their sentences at the same offset from each other, however, you will never be able to completely decode what each of them are saying. But if they keep repeating their sentences, only with overlap at different times, you will eventually be able to understand what they are saying by piecing the individual parts together. Similarly, by varying the amount that the BOLD responses overlap, over time we can reconstruct a clearer picture of what they look like individually.</p>
</div>
<p>You may ask whether there is an optimal amount of jitter that can be applied to every experiment, given the length of the scan and the number of trials. There are in fact software packages designed to create a timing schedule that optimizes the power of your design, which is the ability to detect an effect if it is there. Before going further, however, you will need to understand the difference between <strong>detection</strong> and <strong>estimation</strong>. Researchers are usually more interested in detection, or the ability to 1) find an effect, and 2) determine whether the amplitude of the BOLD response is significant for a condition compared to baseline, or whether the BOLD response for one condition is significantly different from another condition. Block designs are excellent for detection, because the BOLD response for one condition is isolated from the others; if there actually is an effect, this experimental design gives you the most power to detect it, and provides the highest signal to noise ratio as well. Similarly, in an event-related design, this means optimizing the interval of time between consecutive trials in order to best discriminate the BOLD response between conditions, and to accurately estimate the magnitude of each condition’s response.</p>
<p>Estimation, on the other hand, is the accurate measurement of individual time points along the BOLD response. This is related to another type of analysis called Finite Impulse Response analysis (FIR), in which time points can be compared to each other, and the magnitude of the BOLD response tested for significant differences. The user specifies the number of time points to estimate and the length of time in which to estimate them. For example, you may want to estimate ten time points within an eighteen-second window, or one every two seconds (including an estimate of time point zero, which indicates the start of the trial). Event-related designs are much better suited for estimation, since jittering the trials allows you to estimate different time points along the curve of the BOLD response; block designs, by contrast, have too much overlap of the same type of trial, which makes it difficult it not impossible to measure the finer details of that condition’s BOLD response.</p>
<figure class="align-default" id="id7">
<img alt="../../_images/AppendixD_DesignTradeoffs.png" src="../../_images/AppendixD_DesignTradeoffs.png" />
<figcaption>
<p><span class="caption-text">Illustration of the tradeoffs between detection and estimation. Block designs provide the best detection, while minimizing estimation; a design with completely randomized intertrial intervals gives the best estimation, but the lowest detection power. Semi-random designs, which give more weight to shorter intertrial intervals than longer intervals (i.e., make the occurrence of shorter intervals relatively more frequent), provide a balance between detection and estimation. Periodic designs, which are like slow event-related designs, yield both poor estimation and low power.</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To look at this from a different perspective, and to understand the trade-off between optimizing jitter and optimizing power for either detection or estimation, consider an experimental design in which just one instance of a trial is presented, and enough time is allowed for the BOLD response to return to baseline before the presentation of the second trial - say, twenty seconds. This would allow for both good estimation and detection, assuming that you had time for enough trials in order to obtain a good signal to noise ratio. However, you will probably run into the limitations of how long you can scan, depending on your budget, and participants usually don’t want to be in the scanner for more than sixty to ninety minutes. Furthermore, you should consider how this feels psychologically: One trial at a time every twenty seconds will likely bore the subject, and you will probably run into attention and fatigue-related confounds.</p>
</div>
<p>To sum up, the best experimental design depends on not just optimizing jitter, but balancing this with the most trials you can reasonably obtain in a given amount of time, and also considering how the experiment feels psychologically. For example, if we had an experiment tapping into cognitive control measured with congruent and incongruent trials, you should be aware of a phenomenon called the Gratton Effect. This is a phenomenon in which the BOLD signal is larger for incongruent trials immediately following congruent trials than it is for congruent trials following congruent trials, or congruent trials following incongruent trials, which may reflect a measure of the preparedness of the brain to process an upcoming incongruent trial. If you generate a timing scheme using either optseq2 or OptimizeX - two popular software packages for creating timings for experimental designs - you may end up with a design that has a large number of incongruent trials preceding congruent trials, which you may or may not want. In any case, you should examine the timing scheme, test it behaviorally, and make sure that participants are able to perform the way you expect. We now turn to examining each of these design optimization packages.</p>
</section>
<section id="design-optimization-with-optseq2">
<h2>Design Optimization with optseq2<a class="headerlink" href="#design-optimization-with-optseq2" title="Link to this heading"></a></h2>
<p><a class="reference external" href="https://surfer.nmr.mgh.harvard.edu/optseq/">Optseq2</a> is developed by Doug Greve of Massachusetts General Hospital. It is a straightforward package to use, and requires a Unix terminal or terminal emulator. Note, however, that optseq does not seem to be actively maintained, and that it is designed to optimize the estimation of your design - in other words, it will make your experiment better able to estimate points along the BOLD response, at the expense of detection.</p>
<p>I have written a walkthrough for optseq2 which can be found <a class="reference external" href="http://andysbrainblog.blogspot.com/2012/09/optseq-and-event-related-designs.html">here</a>, along with videos demonstrating how to use it.</p>
</section>
<section id="design-optimization-with-optimizex">
<h2>Design Optimization with OptimizeX<a class="headerlink" href="#design-optimization-with-optimizex" title="Link to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Most of the text and figures in this section and the following section are taken from the annual University of Michigan fMRI Training Course.</p>
</div>
<p>Another optimization tool is <a class="reference external" href="http://www.bobspunt.com/easy-optimize-x/">OptimizeX</a>, developed by Bob Spunt. This is a Matlab package that generates timing schedules to maximize detection of the BOLD response, and you can indicate which contrast you want to optimize out of all the possible combinations of your design matrix.</p>
<p>This package will also help you to maximize your design <strong>efficiency</strong>, which can be thought of as the inverse of variance. If we have a timing scheme that optimizes the sampling along different curves of the BOLD response, we will reduce our uncertainty of the shape of the individual BOLD response for each condition, and therefore increase our power to detect an effect that is actually there. In other words, efficiency is a measure of how well the timing scheme allows SPM to deconvolve the amplitudes of the individual conditions, and, all things being equal, a higher efficiency is more desirable. Best of all, efficiency can be calculated before you begin scanning, which can save you time and money from having to later edit your design.</p>
<figure class="align-default" id="id8">
<img alt="../../_images/AppendixD_Efficiency.png" src="../../_images/AppendixD_Efficiency.png" />
<figcaption>
<p><span class="caption-text">Illustration of the difference in power yield for the most efficient and least efficient timing schedule for a given experiment, focusing on a sample size of N=30 subjects. Note that this assumes everything else is equal - number of conditions and number of trials - all that changes is the timing between the trials. Figure courtesy of Jeanette Mumford.</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>To get started, click on the link above and then click on <code class="docutils literal notranslate"><span class="pre">Download</span> <span class="pre">ZIP</span></code> from the menu bar on the left. When it has finished downloading, unzip the package, and then (assuming that it is in your Downloads directory), move it to your home directory and add it to your Matlab path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mkdir</span> <span class="s1">&#39;~/OptimizeX/Demo&#39;</span>
<span class="n">movefile</span><span class="p">(</span><span class="s1">&#39;~/Downloads/spunt-easy-optimize-x-7c4d2f8/*&#39;</span><span class="p">,</span> <span class="s1">&#39;~/OptimizeX&#39;</span><span class="p">)</span>
<span class="n">addpath</span> <span class="s1">&#39;~/OptimizeX&#39;</span>
<span class="n">cd</span> <span class="o">~/</span><span class="n">OptimizeX</span><span class="o">/</span><span class="n">Demo</span>
</pre></div>
</div>
<p>This will create the folders <code class="docutils literal notranslate"><span class="pre">OptimizeX</span></code> and the subfolder <code class="docutils literal notranslate"><span class="pre">DemoFiles</span></code> in your home directory; the scripts to run OptimizeX will be placed in the <code class="docutils literal notranslate"><span class="pre">OptimizeX</span></code> folder, and we have the subdirectory into which we can write out our example timing schedules.</p>
<p>If you then type</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">optimizeXGUI</span>
</pre></div>
</div>
<p>You should now see the main input dialogue:</p>
<figure class="align-default">
<img alt="../../_images/AppendixD_OptimizeX_GUI.png" src="../../_images/AppendixD_OptimizeX_GUI.png" />
</figure>
<p>The menu has the following options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">General</span> <span class="n">Settings</span>

<span class="n">TR</span> <span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="n">TR</span> <span class="n">you</span> <span class="n">will</span> <span class="n">use</span> <span class="n">to</span> <span class="n">acquire</span> <span class="n">images</span>
<span class="n">High</span><span class="o">-</span><span class="n">Pass</span> <span class="n">Filter</span> <span class="n">Cutoff</span> <span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="n">high</span><span class="o">-</span><span class="k">pass</span> <span class="nb">filter</span> <span class="n">you</span> <span class="n">will</span> <span class="n">use</span> <span class="n">to</span> <span class="n">analyze</span> <span class="n">images</span>
<span class="n">Task</span> <span class="n">Settings</span>

<span class="n">N</span> <span class="n">Conditions</span><span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="n">conditions</span> <span class="ow">in</span> <span class="n">your</span> <span class="n">design</span>
<span class="n">N</span> <span class="n">Trials</span> <span class="n">Per</span> <span class="n">Condition</span><span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="n">trials</span> <span class="n">per</span> <span class="n">condition</span> <span class="p">(</span><span class="n">unbalanced</span> <span class="n">OK</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="p">,</span> <span class="mi">25</span> <span class="mi">20</span> <span class="mi">15</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">Maximum</span> <span class="n">Block</span> <span class="n">Size</span><span class="p">:</span> <span class="n">block</span> <span class="o">=</span> <span class="n">trials</span> <span class="kn">from</span> <span class="nn">same</span> <span class="n">condition</span> <span class="n">occurring</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">row</span>
<span class="n">Timing</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="n">Time</span> <span class="n">Duration</span><span class="p">:</span> <span class="n">duration</span> <span class="n">of</span> <span class="n">your</span> <span class="n">trials</span> <span class="p">(</span><span class="mi">0</span> <span class="n">purely</span> <span class="n">event</span><span class="o">-</span><span class="n">related</span><span class="p">)</span>
<span class="n">Mean</span> <span class="n">ISI</span><span class="p">:</span> <span class="n">mean</span> <span class="n">interstimulus</span> <span class="n">interval</span>
<span class="n">Min</span> <span class="n">ISI</span><span class="p">:</span> <span class="n">minimum</span> <span class="n">value</span> <span class="k">for</span> <span class="n">interstimulus</span> <span class="n">interval</span>
<span class="n">Max</span> <span class="n">ISI</span><span class="p">:</span> <span class="n">maximum</span> <span class="n">value</span> <span class="k">for</span> <span class="n">interstimulus</span> <span class="n">interval</span>
<span class="n">Time</span> <span class="n">before</span> <span class="n">first</span> <span class="n">trial</span><span class="p">:</span> <span class="s2">&quot;rest&quot;</span> <span class="n">interval</span> <span class="n">to</span> <span class="n">add</span> <span class="n">to</span> <span class="n">beginning</span> <span class="n">of</span> <span class="n">scan</span>
<span class="n">Time</span> <span class="n">after</span> <span class="n">last</span> <span class="n">trial</span><span class="p">:</span> <span class="s2">&quot;rest&quot;</span> <span class="n">interval</span> <span class="n">to</span> <span class="n">add</span> <span class="n">at</span> <span class="n">end</span> <span class="n">of</span> <span class="n">scan</span>
<span class="n">Optimization</span> <span class="n">Settings</span>

<span class="n">N</span> <span class="n">Designs</span> <span class="n">to</span> <span class="n">Save</span><span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="s2">&quot;optimal&quot;</span> <span class="n">designs</span> <span class="n">to</span> <span class="n">save</span>
<span class="n">N</span> <span class="n">Generations</span> <span class="n">to</span> <span class="n">Run</span><span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="n">generations</span> <span class="n">to</span> <span class="n">test</span>
<span class="n">N</span> <span class="n">Designs</span> <span class="n">Per</span> <span class="n">Generation</span><span class="p">:</span> <span class="n">number</span> <span class="n">of</span> <span class="n">designs</span> <span class="n">to</span> <span class="n">include</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">generation</span>
<span class="n">Max</span> <span class="n">Time</span> <span class="n">to</span> <span class="n">Run</span> <span class="p">(</span><span class="n">minutes</span><span class="p">):</span> <span class="n">maximum</span> <span class="n">amount</span> <span class="n">of</span> <span class="n">time</span> <span class="n">to</span> <span class="n">run</span> <span class="n">the</span> <span class="n">program</span>
</pre></div>
</div>
<p>Feel free to create your own unique design by modifying the inputs. Or, you can just use the “default” values to proceed on to the next step, which is to tell the software which contrasts you care most about:</p>
<figure class="align-default">
<img alt="../../_images/AppendixD_Settings.png" src="../../_images/AppendixD_Settings.png" />
</figure>
<p>This is me telling the software that I am looking for a design that maximizes the efficiency of two contrasts among my conditions</p>
<figure class="align-default">
<img alt="../../_images/AppendixD_ContrastSpecification.png" src="../../_images/AppendixD_ContrastSpecification.png" />
</figure>
<p>This indicates that although I do care about the comparison among predictors 1 and 3 (Contrast 1), I actually care more about the comparison of predictors 2 and 4 (Contrast 2).</p>
<p>That’s it! The software will do the rest of the work, some of which you can see in the MATLAB command window:</p>
<figure class="align-default">
<img alt="../../_images/AppendixD_MatlabOutput.png" src="../../_images/AppendixD_MatlabOutput.png" />
</figure>
<p>Note that the efficiency values have no unit and that larger values indicate more efficient designs.</p>
<p>Once it finishes, you should see a figure pop up showing you the most efficient design matrix:</p>
<figure class="align-default">
<img alt="../../_images/AppendixD_DesignMatrix.png" src="../../_images/AppendixD_DesignMatrix.png" />
</figure>
<p>In addition, you should see a new folder starting with ‘<a href="#id9"><span class="problematic" id="id10">best_designs_</span></a>’ followed by the current date in the directory in which you ran the program (which should be <code class="docutils literal notranslate"><span class="pre">~/OptimizeX/Demo</span></code>. Inside that directory are .csv files and their corresponding .txt files for each of the of the number of designs that you set to write out in the OptimizeX menu (under ‘N Designs to Save’). You can load the .csv files into Matlab or Excel, which would look like this:</p>
<figure class="align-default">
<img alt="../../_images/AppendixD_TimingSchedule.png" src="../../_images/AppendixD_TimingSchedule.png" />
</figure>
<p>You can read in the .txt files in Matlab and display their contents with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;design1.txt&#39;</span><span class="p">);</span>
<span class="n">design1</span>
</pre></div>
</div>
<p>Alternatively, OptimizeX also writes out the file designinfo.mat, which includes a structure with all the designs that you requested OptimzeX to save. You can read it into Matlab with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;designinfo.mat&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>…and access for example the first design in the structure using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">design</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">combined</span>
</pre></div>
</div>
<p>For most applications, this should be all of the information you need to implement your experiment, and to do so in a manner that is optimal given the contrasts you care about. Of course, you might want to think about running the software for more than a minute if you do decide to use this for a study! There is no hard-and-fast rule for how long you do need to run it, but it wouldn’t hurt (presumably) to run it overnight.</p>
</section>
<section id="evaluating-design-efficiency">
<h2>Evaluating Design Efficiency<a class="headerlink" href="#evaluating-design-efficiency" title="Link to this heading"></a></h2>
<p>In the previous two sections, you got a feel for design optimization. In this last section, we’ll learn to more concretely assess design efficiency. This will allow you to evaluate and compare designs, and better understand how to optimize them.</p>
<p>Let’s begin by evaluating the optimized design that you just created. Within the OptimizeX folder, your design should have been saved in a directory called “best_designs_DATE_TIME.” Locate that directory, which should be under <code class="docutils literal notranslate"><span class="pre">~/OptimizeX/Demo</span></code>, and load the file “designinfo.mat”.</p>
<p>load designinfo % make sure you are in the right directory
This will load a variable called “design” into your workspace that contains the design information for each of the designs you generated. In particular, the design matrix is stored in a field called “X”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">design</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">X</span><span class="p">;</span> <span class="o">%</span> <span class="n">store</span> <span class="n">the</span> <span class="n">first</span> <span class="n">design</span> <span class="n">matrix</span> <span class="n">into</span> <span class="n">variable</span> <span class="n">X</span>
<span class="n">figure</span>
<span class="n">imagesc</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">colormap</span><span class="p">(</span><span class="s1">&#39;gray&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This command will plot the design matrix you observed before, but without the intercept (the last column that was on the right).</p>
<p>Now, let’s evaluate the design. First, we’ll examine the variance inflation factors (VIF). Variation inflation factors estimate how stable/unstable parameter estimates will be. You get one variance inflation factor per regressor. A variance inflation factor of 1 is perfect and indicates that the design will provide a stable estimate of the parameter. A variance inflation factor of 2 indicates that there will be a twofold increase in the variance of the parameter. In other words, if you were to repeat the experiment over and over assuming the same underlying true parameter, the estimate of that parameter would be variable to a factor of 2. Similarly, a variance inflation factor of 3 indicates a threefold increase, and so on. There is no hard rule on how much variance inflation one can tolerate, but the lower the better!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vif</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span><span class="s1">&#39;;</span>
<span class="n">vif</span>
</pre></div>
</div>
<p>Are the VIFs near 1? Are they high (e.g. &gt; 10)? VIFs are inflated due to multi-collinearity. Let’s take a look at the correlation between regressors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">corrcoef</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="n">r</span>
</pre></div>
</div>
<p>This shows the correlation matrix. Are there strong correlations between any regressors? How might you decrease the correlation between regressors?</p>
<p>Next, we will look at the efficiency of the design. While variance of parameter estimates (VIFs) are bad, variance of the regressors used to estimate those parameters is good. This is because variance in a regressor gives it a unique signature that can be observed in the signal (if it is there).</p>
<p>More technically, efficient designs minimize the quantity (X’X)-1. Or in MATLAB inv(X’<a href="#id1"><span class="problematic" id="id2">*</span></a>X). In particular, we are interested in the diagonal elements of this matrix, each of which corresponds to a predictor in our design. So, we’ll calculate this quantity and focus on the diagonals. Since we typically think of efficiency in positive terms (i.e. more efficiency is better), we’ll take the reciprocal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eff</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">diag</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="s1">&#39;*X)))&#39;</span><span class="p">;</span>
<span class="n">eff</span>
</pre></div>
</div>
<p>Note that this is a unit-less measure. It is affected by the scaling of the design matrix (and scaling of contrasts when we calculate contrast efficiency). As a result, it is a relative term and comparing grossly different designs is not meaningful. But, so long as we keep our scaling constant, we can compare different simulations of a design (e.g., same number of conditions and trials) using this metric.</p>
<p>While higher efficiency for each regressor is a good thing, what we are typically interested in are contrasts. When you ran the optimizeX script previously, you gave it the contrasts that you wanted to be optimized. Let’s see the metric it used to measure this. The contrasts you gave the script were saved in the variable “params.L.”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">L</span><span class="s1">&#39;; </span><span class="si">% e</span><span class="s1">xtract the contrasts and transpose for matrix multiplication</span>
<span class="n">effCons</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="s1">&#39;*inv(X&#39;</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="p">))</span><span class="s1">&#39;;</span>
<span class="n">effCons</span>
</pre></div>
</div>
<p>Again, this is unit-less and should be used for relative comparisons. If you told the script to weight one contrast more than another, you might see that the more highly weighted contrast has greater efficiency. If you asked for equal weighting, then both contrast efficiencies should be about equivalent.</p>
<p>Next, re-run the Optimization script, but this time, increase the ISI. How does this change affect the VIFs? The efficiency?</p>
<p>Finally, you may be interested in evaluating designs you have used in the past. Locate the SPM.mat file of the design that you have estimated, which contains the design matrix, which you can access with the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">load</span> <span class="n">SPM</span> <span class="o">%</span> <span class="n">make</span> <span class="n">sure</span> <span class="n">you</span> <span class="n">are</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">right</span> <span class="n">directory</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">SPM</span><span class="o">.</span><span class="n">xX</span><span class="o">.</span><span class="n">X</span><span class="p">(:,</span><span class="n">SPM</span><span class="o">.</span><span class="n">Sess</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">col</span><span class="p">);</span> <span class="o">%</span> <span class="n">pick</span> <span class="n">out</span> <span class="n">Session</span><span class="o">/</span><span class="n">Run</span> <span class="mi">1</span>

<span class="o">%</span> <span class="n">Now</span> <span class="n">let</span><span class="s1">&#39;s get the contrast from our SPM file</span>
<span class="n">xCon</span><span class="o">=</span><span class="n">horzcat</span><span class="p">(</span><span class="n">SPM</span><span class="o">.</span><span class="n">xCon</span><span class="p">(:)</span><span class="o">.</span><span class="n">c</span><span class="p">)</span><span class="s1">&#39;;</span>
<span class="n">xCon</span><span class="o">=</span><span class="n">xCon</span><span class="p">(:,</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>This code extracts the regressors for the first session/run. If you had a multi-session/run design, you could change the column indexing to access different sessions/runs, or all of them. Now, you can repeat the steps above to examine the VIFs and efficiencies. Are there any VIFs that are particularly bad? Are there any regressors that are relatively inefficient? If so, what elements of the design do those correspond to? Will this be problematic for the design estimation? These are questions you will need to ask yourself as you decide on the best design to use.</p>
</section>
<section id="video">
<h2>Video<a class="headerlink" href="#video" title="Link to this heading"></a></h2>
<p>You can see how to do this on your computer by watching <a class="reference external" href="https://www.youtube.com/watch?v=PZ7SPH9JfR0&amp;ab_channel=AndrewJahn">this video</a>.</p>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h2>
<p>You now have the tools and concepts to optimize your design: First, by increasing the efficiency of your design matrix using OptimizeX, and also by thinking about any potential confounds that might arise with a given design. Remember that the most efficient design doesn’t necessarily mean the best one; you will have to decide for yourself whether a given timing schedule “feels” right, and for this there is no substitute for experience.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="AppendixC_ParametricModulation.html" class="btn btn-neutral float-left" title="Appendix C: Parametric Modulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../FunctionalConnectivity/CONN_Overview.html" class="btn btn-neutral float-right" title="Functional Connectivity and the CONN Toolbox" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Andy Jahn.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>